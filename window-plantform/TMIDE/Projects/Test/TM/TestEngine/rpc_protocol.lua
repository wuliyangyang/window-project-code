local json = require("dkjson")math.randomseed(os.time())local JSON_RPC_VERSION = "2.0"local _ALLOWED_REPLY_KEYS = {"id", "jsonrpc", "error", "result"}local _ALLOWED_REQUEST_KEYS = {"id", "jsonrpc", "method", "args", "kwargs"}local function contains(t, e)    for i = 1,#t do        if t[i] == e then return true end    end    return falseenddeclare("JSONRPCSuccessResponse", {})JSONRPCSuccessResponse.__index = JSONRPCSuccessResponsesetmetatable(JSONRPCSuccessResponse, {  __call = function (cls, ...)    return cls.new(...)  end,})function JSONRPCSuccessResponse.new()  local self = setmetatable({}, JSONRPCSuccessResponse)  return selfendfunction JSONRPCSuccessResponse:_to_dict()    return {        jsonrpc= JSON_RPC_VERSION,        id= self.id,        -- ["method"] = self["method"],        result= self.result    }endfunction JSONRPCSuccessResponse:serialize()    return json.encode(self:_to_dict())end    -------------------------------------------------------------declare("JSONRPCErrorResponse", {})JSONRPCErrorResponse.__index = JSONRPCErrorResponsesetmetatable(JSONRPCErrorResponse, {  __call = function (cls, ...)    return cls.new(...)  end,})function JSONRPCErrorResponse.new()  local self = setmetatable({}, JSONRPCErrorResponse)  return selfendfunction JSONRPCErrorResponse:_to_dict()    return {        jsonrpc= JSON_RPC_VERSION,        id= self.id,        -- ["method"] = self["method"],        ["error"]= {            message= tostring(self["error"]),            code= self._jsonrpc_error_code,        }    }endfunction JSONRPCErrorResponse:serialize()    return json.encode(self:_to_dict())end---------------------------------------------------------------declare("JSONRPCRequest", {})JSONRPCRequest.__index = JSONRPCRequestsetmetatable(JSONRPCRequest, {  __call = function (cls, ...)    return cls.new(...)  end,  __eq = function (self, other)    return (self["method"] ~= other["method"] and           self.args ~= other.args and            self.kwargs ~= other.kwargs)  end,})--[[--A unique ID to remember the request by. Protocol specific, may ormay not be set. This value should only be set by :`RPCProtocol.create_request`.]]--function JSONRPCRequest.new()  local self = setmetatable({}, JSONRPCRequest)  return selfend--[[--Create a response.Call this to return the result of a successful method invocation.This creates and returns an instance of a protocol-specific subclass of:`RPCResponse`.:param result: Passed on to new response instance.:return: A response or ``None`` to indicate this request does not expect a         response.]]--function JSONRPCRequest:error_respond(error)    if not self.id then        return nil    end    local response = JSONRPCErrorResponse()    local errcode = string.match(tostring(error), "ERRCODE%[(.-)%]")    local errmsg = string.match(tostring(error), "ERRCODE%[.-%](.+)")    if errcode == nil or errmsg == nil then        errcode = -999        errmsg = tostring(error)    end    response.error = errmsg    response.id = self.id    response["method"] = self["method"]    response._jsonrpc_error_code = errcode    return responseend--[[--Create a response.Call this to return the result of a successful method invocation.This creates and returns an instance of a protocol-specific subclass of:`RPCResponse`.:param result: Passed on to new response instance.:return: A response or ``None`` to indicate this request does not expect a         response.]]--function JSONRPCRequest:respond(result)    local response = JSONRPCSuccessResponse()    if not self.id then        return nil    end    response["method"] = self["method"]    response.result = result    response.id = self.id    return responseendfunction JSONRPCRequest:_to_dict()    local jdata = {        jsonrpc= JSONRPCProtocol.JSON_RPC_VERSION,        ["method"]= self["method"],    }    if self.args then        jdata["args"] = self.args    end    if self.kwargs then        jdata["kwargs"] = self.kwargs    end    if self.id ~= nil then        jdata["id"] = self.id    end    return jdataend--[[--Returns a serialization of the request.:return: A string to be passed on to a transport.]]--function JSONRPCRequest:serialize()    return json.encode(self:_to_dict())end---------------------------------------------------------------declare("JSONRPCProtocol", {})JSONRPCProtocol.__index = JSONRPCProtocolsetmetatable(JSONRPCProtocol, {  __call = function (cls, ...)    return cls.new(...)  end,})function JSONRPCProtocol.new()    local self = setmetatable({}, JSONRPCProtocol)    return selfend--[[--Creates a new RPCRequest object.:param method: The method name to invoke.:param args: The positional arguments to call the method with.:return: A new :`RPCRequest` instance.]]--function JSONRPCProtocol:create_request(method, ...)    local request = JSONRPCRequest()    request.id = math.random()    request["method"] = method    request.args = {}    for i,v in ipairs(arg) do        if type(v) == "table" then             request.kwargs = v        else            table.insert(request.args, v)        end    end    if next(request.args) then        request.args = nil    end    return requestend--[[Parses a request given as a string and returns an:class:`RPCRequest` instance.:return: An instanced request.]]--function JSONRPCProtocol:parse_request(data)    --print (" < JSONRPCProtocol Received data> ",tostring(data))    local req, pos, err = json.decode (data, 1, nil)    --print (" < JSONRPCProtocol Received data> ",tostring(req),tostring(pos),tostring(err))    local msg_obj = JSONRPCRequest()    --print (" < JSONRPCProtocol JSONRPCRequest msg_obj> ",tostring(msg_obj))    if err or req == nil then        return nil    end    for k,_ in pairs(req) do        if not contains(_ALLOWED_REQUEST_KEYS, k) then            print("request Key not allowed:" ..  tostring(k))            return nil        end    end    msg_obj["method"] = req["method"]    msg_obj.jsonrpc = req.jsonrpc    msg_obj.id = req.id        if (req.args) then        msg_obj.param1 = req.args[1]        msg_obj.param2 = req.args[2]    else        msg_obj.param1 = nil        msg_obj.param2 = nil    end    if (req.kwargs) then         if (req.kwargs.timeout) then            msg_obj.timeout = req.kwargs.timeout        else            msg_obj.timeout = 3000        end        if(req.kwargs.unit) then            msg_obj.unit = req.kwargs.unit        else            msg_obj.unit = nil        end    end    return msg_objend--[[--Parses a reply and returns an :class:`RPCResponse` instance.:return: An instanced response.]]--function JSONRPCProtocol:parse_reply(data)    local rep = json.decode(data)    for k,v in pairs(rep) do        if not contains(_ALLOWED_REPLY_KEYS, k) then            error("Key not allowed:" ..  tostring(k))        end    end    if rep["jsonrpc"] == nil then        error("Missing jsonrpc (version) in response.")    end    if rep["jsonrpc"] ~= JSON_RPC_VERSION then        error("Wrong JSONRPC version")    end    if rep["id"] == nil then        error("Missing id in response")    end    if rep["error"] == rep["result"] then        error("Reply must contain exactly one of result and error.")    end    local response = nil    if  (rep["error"] ~= nil) then        response = JSONRPCErrorResponse()        error = rep["error"]        response.error = error["message"]        response._jsonrpc_error_code = error["code"]    else        response = JSONRPCSuccessResponse()        response.result = rep["result"]    end    response.id = rep["id"]    return responseend